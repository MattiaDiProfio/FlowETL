root INFO - 14/04/2025 11:07:47 AM : Connected to broker
kafka.consumer.subscription_state INFO - 14/04/2025 11:07:47 AM : Updated partition assignment: [TopicPartition(topic='optimalPlans', partition=0)]
kafka.conn INFO - 14/04/2025 11:07:47 AM : <BrokerConnection node_id=1001 host=localhost:9092 <connecting> [IPv6 ('::1', 9092, 0, 0)]>: connecting to localhost:9092 [('::1', 9092, 0, 0) IPv6]
kafka.conn INFO - 14/04/2025 11:07:47 AM : <BrokerConnection node_id=1001 host=localhost:9092 <connecting> [IPv6 ('::1', 9092, 0, 0)]>: Connection complete.
kafka.conn INFO - 14/04/2025 11:07:47 AM : <BrokerConnection node_id=bootstrap-0 host=localhost:9092 <connected> [IPv6 ('::1', 9092, 0, 0)]>: Closing connection. 
root INFO - 14/04/2025 11:09:15 AM : Received optimal plan -> ['chess_games_source.csv', {'associated_key': None}, {'standardiseFeatures': '```python\n{\n    ("id",): ("game_id",),\n    ("rated",): ("is_rated",),\n    ("created_at",): ("start_time",),\n    ("last_move_at",): ("end_time",),\n    ("turns",): ("turns_taken",),\n    ("victory_status",): ("victory_status",),\n    ("winner",): ("winner",),\n    ("white_id",): ("w_id",),\n    ("white_rating",): ("w_rating",),\n    ("black_id",): ("b_id",),\n    ("black_rating",): ("b_rating",),\n    ("moves",): ("moves_sequence",),\n    ("opening_name",): ("opening_strategy_name",),\n    ("increment_code",): (),\n    ("opening_eco",): (),\n    ("opening_ply",): ()\n}\n```'}, 'missingValues/impute', 'duplicates', 'outliers/impute', {'standardiseValues': '```python\ndef transform_table(input_table):\n    header = input_table[0]\n    data_rows = input_table[1:]\n    output_rows = [header]  # Keep the header as is\n    \n    # Find indices for each column\n    game_id_idx = header.index(\'game_id\') if \'game_id\' in header else -1\n    is_rated_idx = header.index(\'is_rated\') if \'is_rated\' in header else -1\n    start_time_idx = header.index(\'start_time\') if \'start_time\' in header else -1\n    end_time_idx = header.index(\'end_time\') if \'end_time\' in header else -1\n    turns_taken_idx = header.index(\'turns_taken\') if \'turns_taken\' in header else -1\n    victory_status_idx = header.index(\'victory_status\') if \'victory_status\' in header else -1\n    winner_idx = header.index(\'winner\') if \'winner\' in header else -1\n    w_id_idx = header.index(\'w_id\') if \'w_id\' in header else -1\n    w_rating_idx = header.index(\'w_rating\') if \'w_rating\' in header else -1\n    b_id_idx = header.index(\'b_id\') if \'b_id\' in header else -1\n    b_rating_idx = header.index(\'b_rating\') if \'b_rating\' in header else -1\n    moves_sequence_idx = header.index(\'moves_sequence\') if \'moves_sequence\' in header else -1\n    opening_strategy_idx = header.index(\'opening_strategy_name\') if \'opening_strategy_name\' in header else -1\n    \n    for row in data_rows:\n        # Skip processing if row doesn\'t match header length\n        if len(row) != len(header):\n            continue\n            \n        new_row = row.copy()\n        \n        # Transform is_rated to "1" for true, "0" for false\n        if is_rated_idx >= 0 and row[is_rated_idx]:\n            if row[is_rated_idx].lower() == \'true\':\n                new_row[is_rated_idx] = "1"\n            elif row[is_rated_idx].lower() == \'false\':\n                new_row[is_rated_idx] = "0"\n        \n        # Replace empty values with placeholder\n        for i in range(len(new_row)):\n            if new_row[i] == \'\':\n                if i in [game_id_idx, w_id_idx, b_id_idx]:\n                    new_row[i] = "a-00"\n                elif i in [w_rating_idx, b_rating_idx]:\n                    new_row[i] = "1500"\n                elif i == winner_idx:\n                    new_row[i] = "draw"\n                elif i == turns_taken_idx:\n                    new_row[i] = "16"\n                elif i == victory_status_idx:\n                    new_row[i] = "draw"\n        \n        # Transform winner field\n        if winner_idx >= 0 and row[winner_idx]:\n            if row[winner_idx].lower() == \'white\':\n                new_row[winner_idx] = "w"\n            elif row[winner_idx].lower() == \'black\':\n                new_row[winner_idx] = "b"\n            elif row[winner_idx].lower() != \'draw\':\n                new_row[winner_idx] = "draw"\n                \n        # Generate a game ID if missing\n        if game_id_idx >= 0 and (not row[game_id_idx] or row[game_id_idx] == \'\'):\n            import hashlib\n            id_components = []\n            if w_id_idx >= 0 and row[w_id_idx]: id_components.append(row[w_id_idx])\n            if b_id_idx >= 0 and row[b_id_idx]: id_components.append(row[b_id_idx])\n            if start_time_idx >= 0 and row[start_time_idx]: id_components.append(row[start_time_idx])\n            if not id_components:\n                new_row[game_id_idx] = "TZJHLljE"\n            else:\n                combined = \'\'.join(id_components)\n                new_row[game_id_idx] = hashlib.md5(combined.encode()).hexdigest()[:8]\n        \n        # Format moves - replace spaces with dashes\n        if moves_sequence_idx >= 0 and row[moves_sequence_idx]:\n            # Extract the first 5-15 moves for brevity\n            moves = row[moves_sequence_idx].split()\n            # Take only first moves that don\'t contain + or #\n            clean_moves = [m for m in moves if \'+\' not in m and \'#\' not in m][:15]\n            new_row[moves_sequence_idx] = "-".join(clean_moves)\n        \n        # Clean and standardize time values\n        for idx in [start_time_idx, end_time_idx]:\n            if idx >= 0 and row[idx]:\n                try:\n                    # Handle scientific notation\n                    if \'E\' in row[idx].upper():\n                        new_row[idx] = row[idx]\n                    else:\n                        val = float(row[idx])\n                        # Round or truncate very long numbers\n                        if val > 1e11:\n                            new_row[idx] = f"{val:.5e}"\n                        else:\n                            new_row[idx] = str(val)\n                except (ValueError, TypeError):\n                    new_row[idx] = "1.50413E+12"\n                    \n        output_rows.append(new_row)\n        \n    return output_rows\n```'}]
root INFO - 14/04/2025 11:09:16 AM : Published the following metrics to Reporter : {'from': 'pre_etl_pipeline', 'contents': {'missing': {'missing_cells_percent': 40.08}, 'outliers': {'numerical_outliers_percent': 2.138}, 'duplicates': {'duplicate_rows_percent': 16.74}, 'dq': 0.803}}
kafka.conn INFO - 14/04/2025 11:09:16 AM : <BrokerConnection node_id=1001 host=localhost:9092 <connecting> [IPv6 ('::1', 9092, 0, 0)]>: connecting to localhost:9092 [('::1', 9092, 0, 0) IPv6]
kafka.conn INFO - 14/04/2025 11:09:16 AM : <BrokerConnection node_id=1001 host=localhost:9092 <connecting> [IPv6 ('::1', 9092, 0, 0)]>: Connection complete.
kafka.conn INFO - 14/04/2025 11:09:16 AM : <BrokerConnection node_id=bootstrap-0 host=localhost:9092 <connected> [IPv6 ('::1', 9092, 0, 0)]>: Closing connection. 
root ERROR - 14/04/2025 11:09:17 AM : Error occured during the transform or load phase : 'NoneType' object is not subscriptable
root INFO - 14/04/2025 11:09:17 AM : Published the following metrics to Reporter : {'from': 'post_etl_pipeline', 'contents': {'missing': {'missing_cells_percent': 0.0}, 'outliers': {'numerical_outliers_percent': 0.0}, 'duplicates': {'duplicate_rows_percent': 0.0}, 'dq': 0.0}}
kafka.producer.kafka INFO - 14/04/2025 11:09:17 AM : Closing the Kafka producer with 4294967.0 secs timeout.
kafka.conn INFO - 14/04/2025 11:09:17 AM : <BrokerConnection node_id=1001 host=localhost:9092 <connected> [IPv6 ('::1', 9092, 0, 0)]>: Closing connection. 
kafka.conn INFO - 14/04/2025 11:09:17 AM : <BrokerConnection node_id=1001 host=localhost:9092 <connected> [IPv6 ('::1', 9092, 0, 0)]>: Closing connection. 
